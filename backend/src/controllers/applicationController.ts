import { Request, Response, NextFunction } from 'express';
import { prisma } from '../lib/prisma';
import { Prisma, ApplicationStatus } from '@prisma/client';

// Define the request body interface with proper types
interface CreateApplicationBody {
  projectId: string;
  formSubmissionId?: string;
  targetOrgId: string;
}

// Create application data type
type ApplicationCreateData = Prisma.applicationsUncheckedCreateInput;

/**
 * @desc    Create a new application
 * @route   POST /api/applications
 * @access  Private
 */
export const createApplication = async (
  req: Request<{}, {}, CreateApplicationBody>,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { projectId, formSubmissionId, targetOrgId } = req.body as CreateApplicationBody;
    const userId = req.user?.id;
    
    if (!userId) {
      res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
      return;
    }
    
    // Validate required fields
    if (!projectId || !targetOrgId) {
      res.status(400).json({
        status: 'error',
        message: 'Project ID and target organization ID are required'
      });
      return;
    }
    
    // Check if project exists and user is the owner
    const project = await prisma.projects.findUnique({
      where: {
        id: projectId
      }
    });
    
    if (!project) {
      res.status(404).json({
        status: 'error',
        message: 'Project not found'
      });
      return;
    }
    
    if (project.ownerId !== userId) {
      res.status(403).json({
        status: 'error',
        message: 'You do not have permission to create an application for this project'
      });
      return;
    }
    
    // Check if target organization exists
    const targetOrg = await prisma.organizations.findUnique({
      where: {
        id: targetOrgId
      }
    });
    
    if (!targetOrg) {
      res.status(404).json({
        status: 'error',
        message: 'Target organization not found'
      });
      return;
    }
    
    // Check if form submission exists if provided
    if (formSubmissionId) {
      const formSubmission = await prisma.form_submissions.findUnique({
        where: {
          id: formSubmissionId
        }
      });
      
      if (!formSubmission) {
        res.status(404).json({
          status: 'error',
          message: 'Form submission not found'
        });
        return;
      }
      
      // Check if the form submission belongs to the user
      if (formSubmission.userId !== userId) {
        res.status(403).json({
          status: 'error',
          message: 'You do not have permission to use this form submission'
        });
        return;
      }
    }
    
    // Get user's organization if any
    const userOrg = await prisma.organization_members.findFirst({
      where: {
        userId
      }
    });
    
    // Create application
    const application = await prisma.applications.create({
      data: {
        projectId,
        formSubmissionId: formSubmissionId || null,
        applicantOrgId: userOrg?.organizationId || null,
        targetOrgId,
        status: ApplicationStatus.DRAFT,
        notes: null
      } as any,  // These fields are auto-generated by Prisma
      include: {
        projects: true,
        organizations_applications_targetOrgIdToorganizations: true,
        form_submissions: true
      }
    });
    
    res.status(201).json({
      status: 'success',
      data: {
        application
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Get all applications for the authenticated user
 * @route   GET /api/applications
 * @access  Private
 */
export const getMyApplications = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const userId = req.user?.id;
    
    if (!userId) {
      res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
      return;
    }
    
    // Get user's projects
    const userProjects = await prisma.projects.findMany({
      where: {
        ownerId: userId
      }
    });
    
    const projectIds = userProjects.map(project => project.id);
    
    // Get applications for user's projects
    const applications = await prisma.applications.findMany({
      where: {
        projectId: {
          in: projectIds
        }
      },
      include: {
        projects: true,
        organizations_applications_targetOrgIdToorganizations: true,
        form_submissions: {
          select: {
            id: true,
            status: true,
            createdAt: true
          }
        }
      },
      orderBy: {
        updatedAt: 'desc'
      }
    });
    
    res.status(200).json({
      status: 'success',
      results: applications.length,
      data: {
        applications
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Get applications for an organization
 * @route   GET /api/applications/organization/:id
 * @access  Private (Organization members only)
 */
export const getOrganizationApplications = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;
    
    if (!userId) {
      res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
      return;
    }
    
    // Check if user is a member of the organization
    const isMember = await prisma.organization_members.findFirst({
      where: {
        organizationId: id,
        userId
      }
    });
    
    if (!isMember && req.user?.role !== 'ADMIN') {
      res.status(403).json({
        status: 'error',
        message: 'You do not have permission to view applications for this organization'
      });
      return;
    }
    
    // Get applications for the organization
    const applications = await prisma.applications.findMany({
      where: {
        targetOrgId: id
      },
      include: {
        projects: true,
        organizations_applications_applicantOrgIdToorganizations: true,
        form_submissions: {
          include: {
            forms: true
          }
        }
      }
    });
    
    res.status(200).json({
      status: 'success',
      results: applications.length,
      data: {
        applications
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Get an application by ID
 * @route   GET /api/applications/:id
 * @access  Private
 */
export const getApplication = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;
    
    if (!userId) {
      res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
      return;
    }
    
    const application = await prisma.applications.findUnique({
      where: {
        id
      },
      include: {
        projects: true,
        organizations_applications_targetOrgIdToorganizations: true,
        form_submissions: true
      }
    });
    
    if (!application) {
      res.status(404).json({
        status: 'error',
        message: 'Application not found'
      });
      return;
    }
    
    // Check if user is authorized to view this application
    const isProjectOwner = await prisma.projects.findFirst({
      where: {
        id: application.projectId,
        ownerId: userId
      }
    });
    
    const isOrgMember = await prisma.organization_members.findFirst({
      where: {
        organizationId: application.targetOrgId,
        userId
      }
    });
    
    if (!isProjectOwner && !isOrgMember && req.user?.role !== 'ADMIN') {
      res.status(403).json({
        status: 'error',
        message: 'You do not have permission to view this application'
      });
      return;
    }
    
    res.status(200).json({
      status: 'success',
      data: {
        application
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Update an application status
 * @route   PATCH /api/applications/:id/status
 * @access  Private
 */
export const updateApplicationStatus = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    const { status, notes } = req.body;
    const userId = req.user?.id;
    
    if (!userId) {
      res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
      return;
    }
    
    // Check if application exists
    const application = await prisma.applications.findUnique({
      where: {
        id
      },
      include: {
        projects: true
      }
    });
    
    if (!application) {
      res.status(404).json({
        status: 'error',
        message: 'Application not found'
      });
      return;
    }
    
    // Check if user is authorized to update this application
    const isProjectOwner = application.projects.ownerId === userId;
    
    const isOrgMember = await prisma.organization_members.findFirst({
      where: {
        organizationId: application.targetOrgId,
        userId
      }
    });
    
    // Project owners can only submit applications
    if (isProjectOwner && status !== 'SUBMITTED') {
      res.status(403).json({
        status: 'error',
        message: 'Project owners can only submit applications'
      });
      return;
    }
    
    // Organization members can only update status for review stages
    if (isOrgMember && !['REVIEWING', 'INTERVIEWING', 'ACCEPTED', 'REJECTED'].includes(status)) {
      res.status(403).json({
        status: 'error',
        message: 'Invalid status update for organization member'
      });
      return;
    }
    
    // If neither project owner nor org member, deny access
    if (!isProjectOwner && !isOrgMember && req.user?.role !== 'ADMIN') {
      res.status(403).json({
        status: 'error',
        message: 'You do not have permission to update this application'
      });
      return;
    }
    
    // Update application status
    const updatedApplication = await prisma.applications.update({
      where: {
        id
      },
      data: {
        status: status as ApplicationStatus,
        notes: notes !== undefined ? notes : undefined
      }
    });
    
    res.status(200).json({
      status: 'success',
      data: {
        application: updatedApplication
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * @desc    Delete an application
 * @route   DELETE /api/applications/:id
 * @access  Private
 */
export const deleteApplication = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const { id } = req.params;
    const userId = req.user?.id;
    
    if (!userId) {
      res.status(401).json({
        status: 'error',
        message: 'Not authenticated'
      });
      return;
    }
    
    // Check if application exists
    const application = await prisma.applications.findUnique({
      where: {
        id
      },
      include: {
        projects: true
      }
    });
    
    if (!application) {
      res.status(404).json({
        status: 'error',
        message: 'Application not found'
      });
      return;
    }
    
    // Check if user is the project owner
    if (application.projects.ownerId !== userId && req.user?.role !== 'ADMIN') {
      res.status(403).json({
        status: 'error',
        message: 'You do not have permission to delete this application'
      });
      return;
    }
    
    // Only allow deletion of draft applications
    if (application.status !== 'DRAFT') {
      res.status(400).json({
        status: 'error',
        message: 'Only draft applications can be deleted'
      });
      return;
    }
    
    // Delete application
    await prisma.applications.delete({
      where: {
        id
      }
    });
    
    res.status(204).send();
  } catch (error) {
    next(error);
  }
}; 